<div>
    <h4>General</h4>
    <ul>
        <li>
            <b class="sub">Application context:</b>
            <a title="a1_1">what is</a>
            <a title="a1_2">lifecycle</a>
            <a title="a1_3" class="label-danger">configuration</a>
            <a title="a1_4" class="label-warning">usage in test</a>
            <a title="a1_5">closing context</a>
            <a title="a1_6" class="label-warning">namespaces</a>
        </li>
        <li>
            <b class="sub">Beans:</b>
            <a title="a2_1" class="label-danger">lifecycle</a>
            <a title="a2_2" class="label-warning">scope</a>
            <a title="a2_3" class="label-danger">IDs</a>
            <a title="a2_4" class="label-warning">scanning</a>
            <a title="a2_5">stereotypes</a>
            <a title="a2_6" class="label-danger">lazy/eager init</a>
            <a title="a2_7" class="label-danger">final/static</a>
            <a title="a2_8" class="label-danger">init/destroy</a>
            <a title="a2_9" class="label-warning">depends-on</a>
        </li>
        <li>
            <b class="sub">DI, IOC:</b>
            <a title="a3_1">what is</a>
            <a title="a3_2">@Autowired</a>
            <a title="a3_5">scalar/literal injection</a>
            <a title="a3_6" class="label-danger">@Value</a>
            <a title="a3_7">$ vs #</a>
            <a title="a3_8">lookup method</a>
        </li>
        <li>
            <b class="sub">Properties:</b>
            <a title="a4_1">PropertySource</a>
            <a title="a4_2" class="label-danger">PropertySourcesPlaceholderConfigurer</a>
            <a title="a4_3">PropertyResolver</a>
        </li>
        <li>
            <b class="sub">PostProcessors:</b>
            <a title="a5_1">BeanFactoryPostProcessor</a>
            <a title="a5_2" class="label-danger">BeanPostProcessor</a>
            <a title="a5_3">order</a>
        </li>
        <li>
            <b class="sub">Profiles:</b>
            <a title="a6_1">what is</a>
            <a title="a6_2">usage</a>
            <a title="a6_3">limitations</a>
        </li>
        <li>
            <b class="sub">Environment:</b>
            <a title="a7_1">what is</a>
            <a title="a7_2">property sources</a>
        </li>
        <li>
            <b class="sub">SpEL:</b>
            <a title="a8_1">what is</a>
            <a title="a8_2">usage</a>
        </li>
    </ul>

    <div class="hidden">
        <div id="a1_1">
            <b>ApplicationContext</b>
            is a Spring IoC container responsible for:
            <ul>
                <li>instantiating</li>
                <li>configuring</li>
                <li>assembling the beans from configuration</li>
            </ul>
        </div>
        <div id="a1_2">
            <ul>
                <li>Initialization
                    <ul>
                        <li>context created</li>
                        <li>beans loaded</li>
                        <li>injected</li>
                        <li>initialized</li>
                        <li>resources are allocated</li>
                    </ul>
                </li>
                <li>Use</li>
                <li>Destruction
                    <ul>
                        <li>context destroyed</li>
                        <li>resources released</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="a1_3">
            <ul>
                <li>
                    <b>XML config</b>
                    <ul>
                        <li>Define beans in xml</li>
                        <li>Add <b>&lt;context:component-scan></b> - automatically detects stereotyped classes and turns on the
                            <b>&lt;context:annotation-config></b> (activates the Spring infrastructure for various annotations
                            to be detected in bean classes, including the JSR-250 annotations)</li>
                        <li>new <b class="r">ClassPathXmlApplicationContext</b>("lifacycle-config.xml"); (<b class="r">"classpath:"</b>
                            is added implicitly to this string. Also ClassPathXmlApplicationContext starts looking from
                            <b class="r">root</b> of the classpath regardless of whether specify "/")</li>
                    </ul>
                </li>
                <li>
                    <b>Java config</b>
                    <ul>
                        <li>Define <b>@Configuration</b> with a <b class="r">mandatory no-args constructor</b></li>
                        <li>Define <b>@Bean</b> in @Configuration/@Component</li>
                        <li>new <b class="r">AnnotationConfigApplicationContext</b>(JavaApplicationConfig.class);</li>
                    </ul>
                </li>
                <li>
                    <b>Java annotations</b>
                    <ul>
                        <li>Add @ComponentScan to the @Configuration</li>
                        <li>Add @ContextConfiguration to the class where bean need to be injected.
                            (if no location is defined Spfing will try to load config my naming convention i.e. MyClass-context.xml)
                            Annotation params:
                            <ul>
                                <li>"locations", (default) "value" - path to XML configuration</li>
                                <li>"classes" - varargs parameter with a Configuration classes</li>
                                <li>"inheritLocations" (boolean) - can change default behavior of inheriting
                                    configuration class (location)
                                </li>
                            </ul>
                        </li>
                        <li>Annotate bean class as
                            <b>@Component</b>
                        </li>
                        <li>Inject bean with
                            <b>@Autowired</b>
                        </li>
                    </ul>
                </li>
            </ul>
            <br/>
            Configuration with <b class="r">@Import</b>(AnotherConfig.class) import beans provided config.<br/><br/>
            <b class="r">Important</b>: In case imported two configurations with the same named beans defined Spring will
            take <b>the last one</b>. E.g. In @Import({Conf1.class, Conf2.class}) Spring will take the same named bean from Conf2.
            If the load <b>order</b> of configuratino will be switched: Conf2 via Order(1) or Conf1 via Order(2) then bean will be taken
            from Conf1 as the last one.
        </div>
        <div id="a1_4">
            <ul>
                <li>implement the <b>ApplicationContextAware</b> interface and obtain context in setter</li>
                <li>extend <b>AbstractJUnit4SpringContextTests</b> / <b>AbstractTestNGSpringContextTests</b> and get
                    access for their protected ApplicationContext field
                </li>
                <li>inject <b>ApplicationContext</b></li>
            </ul>
        </div>
        <div id="a1_5">
            <ul>
                <li>For WEB: closed automatically</li>
                <li>For non-WEB:
                    <ul>
                        <li><b>registerShutdownHook()</b>: app context will be closed on JVM shutdown (applied by
                            default
                            in Spring Boot);
                        </li>
                        <li><b>close()</b>: app context will be closed immediately</li>
                    </ul>
                </li>
            </ul>
            It's possible to <b>listen to an ContextClosedEvent</b> using ConfigurableApplicationContext.<b>addApplicationListener</b> to do some
            actions before close() of registerShutdownHook()
        </div>
        <div id="a1_6">
            Available namespaces:
            <ul>
                <li><b>c</b> - ingesting by constructor arguments</li>
                <li><b>p</b> - ingesting by setters</li>
                <li><b>util</b>
                    <ul>
                        <li>util:constant - accessing constants in config</li>
                        <li>util:properties - reading properties from a file</li>
                        <li>util:list, util:set, util:map - creating collections</li>
                    </ul>
                </li>
                <li><b>jdbc</b> - e.g. <b class="r">jdbc:embedded-database</b></li>
                <li><b>context</b> - e.g. <b class="r">context:property-placeholder</b> reads properties from a file</li>
                <li><b>aop</b> - e.g. <b class="r">aop:aspectj-autoproxy</b> enables detection of @Aspect bean</li>
                <li><b>tx</b> - e.g. <b class="r">tx:annotation-driven</b> - transactional behavior based on annotations
                    and <b class="r">tx:advice</b> creates transactional advice</li>
                <li>others...</li>
            </ul>
        </div>
        All namespaces are imported as: xmlns:<b>name</b>="http://www.springframework.org/schema/<b>name</b>" + XSD if required.
    </div>

    <div class="hidden">
        <div id="a2_1">
            <ul>
                <li>Load Bean definitions
                    <ul>
                        <li>Bean Definitions are loaded</li>
                        <li>Bean Definitions are processed</li>
                    </ul>
                </li>
                <li>Create Beans
                    <ul>
                        <li>constructor call</li>
                        <li>setter call</li>
                        <li>postprocessor “init” methods call</li>
                    </ul>
                </li>
                <li>Beans are ready and being used</li>
                <li>Beans are destroyed
                    <ul>
                        <li>destroy method call</li>
                        <li>handing over to garbage collector</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="a2_2">
            <ul>
                <li>
                    <b>singleton</b>
                    (default) - one object instance per IoC container. Ideally used for <b class="r">stateless</b> beans.
                </li>
                <li>
                    <b>prototype</b>
                    - one object instance per bean request from container. Ideally used for <b class="r">stateful</b> beans.
                    Configured <b class="r">destruction</b> lifecycle callbacks are <b class="r">not called</b> on prototypes -
                    client code must clean up prototype-scoped objects and release resources that the prototype bean is holding
                    (e.g. using a custom bean post-processor)
                </li>
                <li>[web only] <b>request</b> - each HTTP request has new instance
                </li>
                <li>[web only] <b>session</b> - one object instance per HTTP session lifecycle
                </li>
                <li>[web only] <b>application</b> - one object instance per ServletContext lifecycle
                </li>
                <li>[web only] <b>websocket</b> - one object instance per WebSocket lifecycle
                </li>
            </ul><br/>
            Note: if a singleton depends on prototype then this Prototype bean will be created on container
            creation.<br/>
            <b>Custom scope</b> is done through implementation of interface <b class="r">Scope</b>.
        </div>
        <div id="a2_3">
            @Bean parameters:
            <ul>
                <li><b>value</b> (default param e.g. @Bean("bName")) - bean name and aliases</li>
                <li><b>name</b> - bean name and aliases</li>
            </ul>
            * 'name' and 'value' are both <b>arrays</b> with identical functionality<br/>
            * @Bean doesn't have '<b class="r">id</b>' or '<b class="r">alias</b>' property<br/>
            * @Bean's default name will be the same as the method name
            <br/><br/>

            &lt;bean/> parameters:
            <ul>
                <li><b>id</b> - exactly one unique identifier for a bean</li>
                <li><b>name</b> - can be used to create one or more aliases</li>
            </ul>
            * aliases can be separated by any number of spaces, commas, or semi-colons (or any mixture of the three)
            <br/><br/>

            In case the name/id is not defined:
            <ul>
                <li><b>@Bean</b> takes the <b class="r">method's name</b></li>
                <li><b>&lt;bean/></b> is considered anonymous and container generates a unique id for that bean:
                    fully qualified <b class="r">class name</b> and appened <b class="r">number</b></li>
            </ul>
        </div>
        <div id="a2_4">
            Responsible for searching beans to register.
            <br/>
            Turned on:
            <ul>
                <li><b>@ComponentScan</b>("com.path")
                </li>
                <li>&lt;context:<b>component-scan</b> base-package="com.path"/>
                </li>
            </ul>
            <br/>
            Detects
            <ul>
                <li>Stereotypes: @Component, @Controller, @Repository, @Service, @RestController</li>
                <li>Other: @ControllerAdvice, @Configuration</li>
            </ul><br/><br/>
            Doesn't require @Configuration to work.
        </div>
        <div id="a2_5">
            Stereotypes ("stereotype" package):
            <br/>
            define the roles class in architecture (eventually targets for pointcuts).
            <br/>
            Stereotypes are:
            <ul>
                <li>
                    <b>@Component</b>
                </li>
                <li>Specializations meta-annotatated with @Component
                    <ul>
                        <li>
                            <b>@Controller</b>
                        </li>
                        <li>
                            <b>@RestController</b> (not from stereotype package but still considered as a stereotype by the Spring spec)
                        </li>
                        <li>
                            <b>@Repository</b>
                        </li>
                        <li>
                            <b>@Service</b>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="a2_6">
            <b>Only singletons</b> are <b>eagerly</b> instantiated by default.
            <br/>
            To alter:
            <ul>
                <li>&lt;bean id="lazy" class="com.foo.HeavyBean" <b>lazy-init</b>="true"/> or<br/>
                    &lt;beans <b>default-lazy-init</b>="true">
                </li>
                <li>
                    <b>@Lazy</b> for @Bean or class with beans. Annotation has the only boolean argument "value" that
                    can turn on/off lazy loading (e.g. <b>@Lazy(false)</b>)
                </li>
            </ul><br/>
            <b class="r">Note</b>: when a lazy-initialized bean is a dependency of a singleton bean that
            is not lazy-initialized, the ApplicationContext creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies.
        </div>
        <div id="a2_7">
            non-static @Bean methods in @Configuration classes need to be overridable,
            <br/>
            i.e. they must not be declared as private or final.
            <br/>
            <br/>
            <b>Static beans features</b>:
            <ul>
                <li>allows a method to be called without creating its containing configuration class as an instance</li>
                <li>It is necessary when beans will get initialized early in the container lifecycle</li>
                <li>It avoids triggering other parts of the configuration at that point of definition</li>
                <li>they will <b class="r">never get intercepted by the container, not even within @Configuration classes</b></li>
                <li>static methods can be final though it doesn't make sense.</li>
            </ul>
        </div>
        <div id="a2_8">
            <b>Init method</b> - called as a callback after bean is created, assembled and <b>all the bean properties are set</b>.
            Declaring options:
            <ul>
                <li>
                    <b>@PostConstruct</b> [JSR-250] (Java config, best practice)
                </li>
                <li>
                    <b>custom init</b> method (Java and XML config)
                    <ul>
                        <li>XML: &lt;beans default-init-method="init"/> or<br/>
                            &lt;bean <b class="r">init-method</b>="init"/></li>
                        <li>Java: @Bean(initMethod = "init")</li>
                    </ul>
                </li>
                <li>
                    <b>afterPropertiesSet()</b>
                    from InitializingBean callback interface (not recommended since
                    couples the code to Spring)
                </li>
            </ul>
            <br/>

            <b>Destruction method</b>
            called on closing the application context. Declaring options:
            <ul>
                <li>
                    <b>@PreDestroy</b>
                    [JSR-250] (Java config, best practice)
                </li>
                <li>
                    <b>custom destroy</b> method (Java and XML config)
                    <ul>
                        <li>XML: &lt;beans default-destroy-method attribute="destroy"/> or &lt;bean destroy-method="destroy"/></li>
                        <li>Java: @Bean(destroyMethod = "destroyMethod")</li>
                    </ul>
                </li>
                <li>
                    <b>destroy()</b>
                    from DisposableBean callback interface (not recommended)
                </li>
            </ul><br/><br/>
            Sequence of calling for init and destroy phases are the same:
            <ul>
                <li><b class="r">before init/destroy BeanPostProcessor</b> call (@PostConstruct / @PreDestroy)</li>
                <li><b class="r">Spring specific</b> interface control (afterPropertiesSet / destroy)</li>
                <li><b class="r">custom init/destroy</b> methods defined in mean annotation/tag arguments</li>
            </ul>

            <br/>
            <b class="r">CommonAnnotationBeanPostProcessor</b> provides support for all JSR annotations. Registered within Spring Application context.
            <br/><br/>
            All of the above can be used on the <b class="r">Configuration</b> as well since its instance will participate in lifacycle.
        </div>
        <div id="a2_9">
            Bean's property <b class="r">@DependsOn</b> or depends-on (XML) informs Spring that some another bean must be created before.
        </div>
    </div>

    <div class="hidden">
        <div id="a3_1">
            DI(IoC) is a technique where one object supplies the dependencies of another object
        </div>
        <div id="a3_2">
            @Autowired:
            <ul>
                <li><b>injects</b> a bean</li>
                <li>handled by Spring <b>BeanPostProcessor</b></li>
                <li>makes injection <b>mandatory</b>. Fails if nothing to inject</li>
                <li>only <b>one constructor</b> can be Autowired, <b>but</b> multiple constructors can be marked as @Autowired(required = false)</li>
                <li>can autowire <b>Map</b> (key:bean name (String only), value:bean of the expected type)</li>
                <li>can autowire <b class="r">array</b> which will have all the beans of array elements type</li>
                <li>applied on a <b>method/constructor</b> will make sure that all arguments will be loaded as beans from AppContext</li>
            </ul><br/>
            Equivalents:
            <ul>
                <li><b>@Inject</b> (javax.injectx package): use with @Qualifier from javax.inject to specify name of the bean to inject</li>
                <li><b>@Resource</b> (javax.annotation package): provides a name attribute to specify name of the bean to inject</li>
            </ul><br/>
            <b>@Required</b> - An exception will be thrown if @Required dependency is not set.<br/>
            <b>@Qualifier</b> defines exact bean name if injection by type finds multiple implementations.
            Can be used on <b class="r">Field, Method, Method's parameter, Class</b><br/><br/>
            <b class="r">Private fields</b> are injected the same way as public.
        </div>

        <div id="a3_5">
            <ul>
                <li>XML: by adding "value" attribute to "property" or "constructor-arg"</li>
                <li>Class: using @Value</li>
            </ul>
        </div>
        <div id="a3_6">
            <ul>
                <li>handled by Spring <b>BeanPostProcessor</b></li>
                <li>can be placed on <b class="r">fields, methods and method/constructor parameters</b></li>
                <li>used for <b>expression-driven dependency injection</b></li>
                <li>supported for dynamic resolution of handler method parameters e.g. in Spring MVC</li>
                <li>an expression resolver is preconfigured to look for bean names when resolving expression text (<b class="r">#{}</b>)</li>
                <li>applied on the <b class="r">method/constructor</b> will make sure that Value will be injected to the
                    method/constructor arguments (string Value will be converted to appropriate type defined in parameter)</li>
            </ul>
        </div>
        <div id="a3_7">
            <ul>Used in @Value
                <li><b>#{}</b> - SpEL expression. Inside the expression variables can be references by #newName, #this, #root
                </li>
                <li><b>${}</b> - "${" is a "placeholder prefix". ${} expression internally will be handled by
                    PropertyResolver.resolvePlaceholders
                </li>
            </ul>
        </div>
        <div id="a3_8">
            <b>Lookup Method Injection</b> replaces method (or implements if abstract) logic with searching a bean in
            the container. If called, the method marked as a "lookup" will simply return found bean. If lookup bean name
            is not defined, container will try to identify searching bean by the method return type.
            <br/><br/>
            Implementations:
            <ul>
                <li><b>@Lookup</b>("otherBean")<br/>
                    abstract Command getOtherBean()</li>
                <li><<b>lookup-method</b> name="getOtherBean" bean="otherBean"/></li>
            </ul><br/>
            Implemented using <b>CGLIB</b>.
        </div>
    </div>

    <div class="hidden">
        <div id="a4_1">
            Declaration:
            <ul>
                <li><b>@PropertySource</b>("classpath:/com/myco/app.properties")
                </li>
            </ul>
            <br/>
            Usage
            <ul>
                <li>@Autowired Environment env; <b>env.getProperty</b>("testbean.name");
                </li>
                <li><b>@Value</b>("${testbean.name}")
                </li>
            </ul>
        </div>
        <div id="a4_2">
            <ul>
                <li>specialization of <b class="r">PlaceholderConfigurerSupport</b></li>
                <li>predefined bean factory <b>post-processor</b></li>
                <li>newer and more flexible version of PropertyPlaceholderConfigurer</li>
                <li><b>Resolves</b> ${} <b class="r">placeholders</b> in bean definition property values and
                    resulves <b class="r">@Value</b> annotations against the
                    current Spring Environment and its set of PropertySources
                </li>
            </ul>
        </div>
        <div id="a4_3">
            "${}" expression internally handled by PropertyResolver.resolvePlaceholders
        </div>
    </div>

    <div class="hidden">
        <div id="a5_1">
            <ul>
                <li>operates on the bean configuration metadata</li>
                <li>can change the actual bean definition (i.e., the blueprint that defines the bean)</li>
                <li>can modify the application context's internal bean factory after the context's standard initialization</li>
            </ul>
        </div>
        <div id="a5_2">
            Operates on already created bean in phases:
            <ul>
                <li>Before initialization callbacks (afterPropertiesSet, init-method)</li>
                <li>After initialization callbacks (afterPropertiesSet, init-method)</li>
            </ul>
        </div>
        <div id="a5_3">
            Both BeanPostProcessor and BeanFactoryPostProcessor, can control the order in which they execute by
            implementing the <b>Ordered</b> or <b>PriorityOrdered</b> interface, not just BeanFactoryPostProcessor.
        </div>
    </div>

    <div class="hidden">
        <div id="a6_1">
            Is a mechanism that allows for <b>registration of different beans in different environments</b>
            <br/>
            Default profile is a "<b>default</b>".
            <br/>
            <br/>
            Useful when (examples):
            <ul>
                <li>Easily changing data sources: in-memory datasource in development, from JNDI for QA</li>
                <li>registering monitoring infrastructure only when deploying an application into a performance
                    environment
                </li>
                <li>registering customized implementations of beans for customer A vs customer B deployments</li>
            </ul>
        </div>
        <div id="a6_2">
            <ul>
                <li>Java: <b>@Profile</b> on @Configuration/@Component/@Bean</li>
                <li>XML: '<b>profile</b>' attribute on &lt;beans></li>
            </ul>
            <br/>
            Activation:
            <ul>
                <li>-D<b>spring.profiles.active</b>="profile1,profile2"</li>
                <li>ctx.getEnvironment().<b>setActiveProfiles</b>("profile1", "profile2")</li>
            </ul>
            <br/>
            Arguments
            <ul>
                <li>@Profile("development")</li>
                <li>@Profile({"p1", "p2"})</li>
                <li>@Profile("<b>!</b>development")  - anything other than "development"</li>
            </ul>
        </div>
        <div id="a6_3">
            It is possible to have <b>MAX array size</b> different profiles expected for registered bean
        </div>
    </div>

    <div class="hidden">
        <div id="a7_1">
            <ul>
                <li>integrated in the container</li>
                <li>contains
                    <ul>
                        <li><b>profiles</b>: which is currently active</li>
                        <li><b>properties</b>: configuring property sources and resolving properties from them</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="a7_2">
            <ul>
                <li>Command line arguments</li>
                <li>Java System properties (System.getProperties())</li>
                <li>OS environment variables (System.getenv())</li>
                <li>Spring Boot application.properties</li>
                <li>Default Properties (set by <b class="r">SpringApplication.setDefaultProperties</b>)</li>
                <li>And many more:
                    https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html
                </li>
            </ul>
        </div>
    </div>

    <div class="hidden">
        <div id="a8_1">
            Spring Expression Language supports <b>querying and manipulating an object graph at runtime</b>
            <br/><br/>
            Functionality:
            <ul>
                <li>Literal expressions</li>
                <li>Boolean and relational operators</li>
                <li>Regular expressions</li>
                <li>Class expressions</li>
                <li>Accessing properties, arrays, lists, maps</li>
                <li>Method invocation</li>
                <li>Relational operators</li>
                <li>Assignment</li>
                <li>Calling constructors</li>
                <li>Bean references</li>
                <li>Array construction</li>
                <li>Inline lists</li>
                <li>Inline maps</li>
                <li>Ternary operator</li>
                <li>Variables</li>
                <li>User defined functions</li>
                <li>Collection projection</li>
                <li>Collection selection</li>
                <li>Templated expressions</li>
            </ul>
        </div>
        <div id="a8_2">
            <ul>
                <li>
                    Manually: <br/>
                    <b>ExpressionParser.parseExpression</b> (from "org.springframework.expression" package)
                </li>
                <li>In Bean Definitions:
                    <ul>
                        <li>XML Config: &lt;property name="prop"
                            <br/>
                            value="<b>#{ T(java.lang.Math).random() * 100.0 }</b>"/>
                        </li>
                        <li>Annotation Config:
                            <br/>
                            @Value("<b>#{ systemProperties['user.region'] }</b>")
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
</div>
